Left off:
debugging and multi threading later
Using transposition tables with hashamps



04/02/24
OK I realised that I had done something very wrong. I had a bug where the colors wouldn't swap properly. and when you reverted moves, all the black moves reverted to white in the minimax algorithm,. I fixed this and the performance is a lot faster now.
Depth 4 from previous 256,123 states, 198 seconds to 206,605 states in 4.3 seconds!!
HOLY SHIT I PLAYED IT AGAINST MARTIN AGAIN AND IT WON. IT SAW MOVES THAT I DIDN'T REALLY THINK OF.
IT GOT A RATING OF 1150 ESTIMATE FROM THE ANALYSIS AND THIS IS JUST DEPTH 4. To be honest the game took
around an hour to play because it's not very efficient ~ it takes around 3-5 minutes to calculate moves. 
Other things to take note of is that it missed checkmate in 1 so that probably needs to be tweaked.


03/02/24
Updated the evaluation function - with dynamic weighting. So far I am factoring position and material.
However based on the amount of material lost, the weighting will be different. For similar material, the position will be weighted more. For vast material difference, the material difference will be factored more. I have used a sigmoid function to get the evaluation for material difference, since 1 point difference is quite minute, however 3 points is losing. Anything above 9-39 points is going to be extremely losing.
I fixed the issues of having only one arraylist in the entire program, to allocating new ones for future moves. I brushed up on some other stuff and now the entire program works with no runtime errors! However there are some bugs because some moves aren't being reverted back in the correct color. There are some issues for when the colors are flipped.
Some figures:
Depth 4: 255,123 games searched, 198 seconds: pawn e2 to e4 (very good!!)
Depth 3: 4882 games searched, 3 seconds
Depth 2: 461 games searched, 0.033 seconds
Depth 1: 21 games searched, 0.007 seconds

01/02/24
There are certain issues that I need to fix now. The game object has an arraylist of moves that it can
perform. Therefore within the minimax algorithm, it will wipe it and update when a new move is called.
This means that the old moves have been removed, and it will be impossible to revert. I need to make
the moves list independent of the game object. Also I am improving the evaluation method by adding material a factor, but I am trying to balance out the weightage.

31/01/24
MiniMax algorithm was setup, but not tested completely. I also added
Piece Square Tables from sources online. The chess engine played its first match against
Martin (250 elo) on chess.com at depth 1. It played terribly and lost in 48 moves. It had an 
overall accuracy of 66.4 % and was rated 100 elo. This is because it only took in 
the piece square tables which are good for developing the pieces, but has no logic in capturing.

28/01/24
Calculate possible moves function completely overhauled. Instead of copying a game
thousands of times, it had the ability to make the move, and then revert the move
back to the original state which had a lot more code complexity, but I was able
to keep the time effiency to about 0.01 seconds, which is so much faster than before.
The two functions makeMove and revertMove took a lot of complexity as you have to save
certain states of the game and restore them.

18/01/24
isCheckMateFunction created. MakeMove function was created. At this stage it had to create
a copy of the board (since it was java, all the references were pointers and not values so
the board had to be copied all 64 squares including castling rights, etc) and then it would
check if you are in check. If you were in check, it would not be a valid move.
If there are no legal moves and you are in check, then it is checkmate
At this point it would take about ~0.734 seconds to generate a legal moves list. In terms of
chess engine efficiency, this is terrible.

14/01/24
Calculate Possible Moves Function created.
Loops through 64 squares and updates which pieces can move or not.
Currently did not handle pins or whether king was in check

10/01/24
GUI created. Control Panel to create enginepanels which displayed the board

08/01/24
Basic evaluation function. Loops through 64 squares and adds up
material. Evaluation only counts material loss and gain

07/01/24
Beginning of project. Researched about FEN notation and realised
that a chess game has a lot more states than just the board:
King Castling Rights for each side, color and En Passant
Produced String handling to input the FEN notation
The way the board is setup is in a 2D array of Piece objects
[0][0] correlates to A1
[7][7] correlates to H7

However, if you try to print it out like this:
for(int i=0; i<8; i++) {
	for(int j=0; i<8;j++) {
		System.out.println(board[i][j].getPieceName());
	}
}

It will print out sideways as you are looping through FILES (Column) instead of the RANKS (Row)
This confused me quite a bit during development.